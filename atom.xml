<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://horizain.github.io</id>
    <title>Horizain</title>
    <updated>2021-08-23T10:11:14.814Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://horizain.github.io"/>
    <link rel="self" href="https://horizain.github.io/atom.xml"/>
    <subtitle>Rain on the horizon</subtitle>
    <logo>https://horizain.github.io/images/avatar.png</logo>
    <icon>https://horizain.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Horizain</rights>
    <entry>
        <title type="html"><![CDATA[第三节补充笔记：本章库函数简介]]></title>
        <id>https://horizain.github.io/post/Tn_i38FpZ/</id>
        <link href="https://horizain.github.io/post/Tn_i38FpZ/">
        </link>
        <updated>2021-08-23T10:06:20.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="c版本">C++版本</h3>
<ol>
<li><code>ros::ServiceServer server = nh.advertiseService(&quot;sum&quot;, doRequest);</code></li>
</ol>
<p>服务端注册函数，使用NodeHandle句柄创建，两个参数分别是：服务名称、回调函数句柄</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="c版本">C++版本</h3>
<ol>
<li><code>ros::ServiceServer server = nh.advertiseService(&quot;sum&quot;, doRequest);</code></li>
</ol>
<p>服务端注册函数，使用NodeHandle句柄创建，两个参数分别是：服务名称、回调函数句柄</p>
<!-- more -->
<ol start="2">
<li><code>ros::ServiceClient client = nh.serviceClient&lt;hello_service_std::sum&gt;(&quot;sum&quot;);</code></li>
</ol>
<p>客户端注册函数，参数为：服务名称</p>
<p>客户端与服务端是通过注册在ROS Master的服务名称匹配的</p>
<ol start="3">
<li>
<p><code>ros::service::waitForService(&quot;sum&quot;);</code></p>
</li>
<li>
<p><code>client.waitForExistence();</code></p>
</li>
</ol>
<p>上面两个函数都是用于客户端等待服务端响应，用法不一样，若服务端无响应，则客户端挂起</p>
<ol start="5">
<li><code>num.request.num1 = atoi(argv[1]);</code></li>
</ol>
<p>这是一个C标准函数，功能是把字符串转换成整型数。原型在<code>&lt;stdlib.h&gt;</code></p>
<p><code>atoi(&quot;123&quot;);</code>结果是<code>123</code>，是一个整型值</p>
<ol start="6">
<li><code>bool flag = client.call(num);</code></li>
</ol>
<p>对一个远程服务器请求调用RPC服务，成功返回True，失败False</p>
<h3 id="最常用">最常用</h3>
<ul>
<li>Setup:
<ul>
<li><a href="https://docs.ros.org/en/api/roscpp/html/namespaceros.html#a7f5c939b8a0548ca9057392cc78d7ecb">ros::init()</a></li>
</ul>
</li>
<li>Publish / subscribe messaging:
<ul>
<li><a href="https://docs.ros.org/en/api/roscpp/html/classros_1_1NodeHandle.html#a6b655c04f32c4c967d49799ff9312ac6">advertise()</a></li>
<li><a href="https://docs.ros.org/en/api/roscpp/html/classros_1_1NodeHandle.html#a317fe4c05919e0bf3fb5162ccb2f7c28">subscribe()</a></li>
</ul>
</li>
<li>RPC services:
<ul>
<li><a href="https://docs.ros.org/en/api/roscpp/html/classros_1_1NodeHandle.html#a0262cf4028324bbcd896b6909ab867ae">advertiseService()</a></li>
<li><a href="https://docs.ros.org/en/api/roscpp/html/classros_1_1NodeHandle.html#aa3376eeca609c4985255cecfaadcbcc5">serviceClient()</a></li>
<li><a href="https://docs.ros.org/en/api/roscpp/html/namespaceros_1_1service.html#a5ce99b7d7556ba798a62987a92796d9d">ros::service::call()</a></li>
</ul>
</li>
<li>Parameters:
<ul>
<li><a href="https://docs.ros.org/en/api/roscpp/html/classros_1_1NodeHandle.html#afb8dbc451e3c0dbc14c67438d21c9f2b">getParam()</a></li>
<li><a href="https://docs.ros.org/en/api/roscpp/html/classros_1_1NodeHandle.html#ad5fa42e137501baf45fbaf6e99edb78a">setParam()</a></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《ROS学习笔记》——第三节：服务通信的理论和实现]]></title>
        <id>https://horizain.github.io/post/3EAwPDCVm/</id>
        <link href="https://horizain.github.io/post/3EAwPDCVm/">
        </link>
        <updated>2021-08-23T10:04:18.000Z</updated>
        <summary type="html"><![CDATA[<p>服务通信主要运用于对<strong>偶然性</strong>、<strong>实时性</strong>有要求，且有一定<strong>逻辑处理需求</strong>的数据传输场景</p>
]]></summary>
        <content type="html"><![CDATA[<p>服务通信主要运用于对<strong>偶然性</strong>、<strong>实时性</strong>有要求，且有一定<strong>逻辑处理需求</strong>的数据传输场景</p>
<!-- more -->
<h3 id="服务通信理论模型">服务通信理论模型：</h3>
<figure data-type="image" tabindex="1"><img src="http://www.autolabor.com.cn/book/ROSTutorials/assets/02_%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt="img" loading="lazy"></figure>
<h3 id="流程步骤">流程步骤：</h3>
<ol start="0">
<li>
<p>Server注册</p>
</li>
<li>
<p>Client注册</p>
</li>
<li>
<p>ROS Master实现信息匹配</p>
</li>
<li>
<p>Client发送请求</p>
</li>
<li>
<p>Server发送响应</p>
</li>
</ol>
<blockquote>
<p><strong>注意：</strong></p>
<ol start="0">
<li>客户端请求时要保证服务器已经启动</li>
<li>服务端和客户端可以存在多个</li>
</ol>
</blockquote>
<p>话题通信和服务通信的握手阶段基本一致，由ROS Master做中介，所有与ROS Master进行的通信都是RPC协议，最后Server和Client的通信则是切换到TCP协议。</p>
<h3 id="服务通信自定义srv">服务通信自定义srv</h3>
<p>srv文件内的可用数据类型与msg文件一致，且自定义实现流程类似。</p>
<h4 id="流程步骤-2">流程步骤：</h4>
<ol start="0">
<li>按照固定格式创建srv文件</li>
<li>编辑配置文件</li>
<li>编译生成中间文件</li>
</ol>
<blockquote>
<p><strong>注意：</strong></p>
<p>服务通信中，数据分成两部分，请求与响应，在 srv 文件中请求和响应使用<code>---</code>分割</p>
</blockquote>
<pre><code># 客户端请求时发送的两个数字
int32 num1
int32 num2
---
# 服务器响应发送的数据
int32 sum
</code></pre>
<p>自定义srv文件中数据类型的顺序是固定的，上面是客户端请求的数据，下面是服务器响应的数据，中间用三个横杠“-”分割</p>
<h4 id="编辑配置文件">编辑配置文件：</h4>
<p><strong>package.xml</strong>中添加编译依赖与执行依赖</p>
<pre><code class="language-xml">  &lt;build_depend&gt;message_generation&lt;/build_depend&gt;
  &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;
  &lt;!-- 
  exce_depend 以前对应的是 run_depend 现在非法
  --&gt;
</code></pre>
<p><strong>CMakeLists.txt</strong>编辑 srv 相关配置</p>
<pre><code class="language-cmake">find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  std_msgs
  message_generation
)

# 需要加入 message_generation,必须有 std_msgs
add_service_files(
  FILES
  AddInts.srv
)

generate_messages(
  DEPENDENCIES
  std_msgs
)
</code></pre>
<h3 id="代码实现注意">代码实现注意：</h3>
<ol start="0">
<li>服务端的回调函数中要有对客户端的数据检测</li>
</ol>
<pre><code class="language-cpp">//逻辑处理
if (num1 &lt; 0 || num2 &lt; 0)
{
    ROS_ERROR(&quot;提交的数据异常:数据不可以为负数&quot;);
    return false;
}
</code></pre>
<ol>
<li>客户端中要有对系统参数的安全检测</li>
</ol>
<pre><code class="language-cpp">// 调用时动态传值,如果通过 launch 的 args 传参，需要传递的参数个数 +3
if (argc != 3)
// if (argc != 5)//launch 传参(0-文件路径 1传入的参数 2传入的参数 3节点名称 4日志路径)
{
    ROS_ERROR(&quot;请提交两个整数&quot;);
    return 1;
}
</code></pre>
<ol start="2">
<li>客户端可以先于服务端启动</li>
</ol>
<pre><code class="language-cpp">ros::service::waitForService(&quot;sum&quot;);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第二节补充笔记：编码过程中库函数简介]]></title>
        <id>https://horizain.github.io/post/jaTAsGEvp/</id>
        <link href="https://horizain.github.io/post/jaTAsGEvp/">
        </link>
        <updated>2021-08-21T15:32:13.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="c版本">C++版本</h3>
<ol>
<li><code>ros::init(argc, argv, &quot;node_name&quot;)</code>;</li>
</ol>
<p>ros系统的初始化函数，使用ros系统提供的APIs的前提必须步骤</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="c版本">C++版本</h3>
<ol>
<li><code>ros::init(argc, argv, &quot;node_name&quot;)</code>;</li>
</ol>
<p>ros系统的初始化函数，使用ros系统提供的APIs的前提必须步骤</p>
<!-- more -->
<ol start="2">
<li><code>ros::NodeHandle nh;</code></li>
</ol>
<p>句柄函数，话题、服务和参数服务器的公共接口</p>
<ol start="3">
<li><code>ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;, 10);</code></li>
</ol>
<p>广播一个话题，同时负责订阅者状态的回调。用到的参数依次是：话题名称，队列大小。尖括号中是使用的信息类型</p>
<ol start="4">
<li><code>ros::Subscriber sub = nh.subscribe&lt;std_msgs::String&gt;(&quot;chatter&quot;, 10, doMsg);</code></li>
</ol>
<p>注册一个话题订阅服务器，接收消息并用回调函数处理。用到的参数依次是：话题名称，队列大小、回调函数名（句柄）</p>
<ol start="5">
<li><code>ros::Rate r(1);</code></li>
</ol>
<p><code>Rate()</code>是一个类，使用前要先实例化。构造函数起到的是一个定时器的作用。允许你指定一个循环的<strong>频率</strong>，该对象会记录距离上次调用<code>Rate::sleep</code>的时间差，并且sleep恰当的时间保证循环频率的正确。</p>
<p>一般<code>Rate::sleep()</code>会包括在一个死循环中，由系统负责任务的调度。</p>
<ol start="6">
<li><code>ros::spin()</code>和<code>ros::spinOnce()</code></li>
</ol>
<p>一看名字就知道这是俩亲兄弟，学名叫<strong>ROS消息回调处理函数</strong>，通常出现在ROS的主循环中，程序需要不断调用<code>spin()</code>或<code>spinOnce()</code>。</p>
<p>这里摘抄一段网上的解释：</p>
<blockquote>
<p>消息订阅器一旦知道chatter上面有data，就会将这data作为参数传入callback函数中，但是此时还没有执行callback函数，而是把callback函数放到了一个回调函数队列中。所以当发布器不断发送data到chatter上面时，就会有相应的callback函数进入队列中，它们函数名一样，只是实参不一样。</p>
<p>那么什么时候才会执行callback函数呢？</p>
<p>就是ros::spin()和ros::spinOnce()的事了。</p>
<p>当spinOnce函数被调用时，spinOnce就会调用回调函数队列中第一个callback函数，此时callback函数才被执行，然后等到下次spinOnce函数又被调用时，回调函数队列中第二个callback函数就会被调用，以此类推。</p>
<p>所以，这会有一个问题。因为回调函数队列的长度是有限的，如果发布器发送数据的速度太快，spinOnce函数调用的频率太少，就会导致队列溢出，一些callback函数就会被挤掉，导致没被执行到。</p>
<p>而对于spin函数，一旦进入spin函数，它就不会返回了，相当于它在自己的函数里面死循环了。只要回调函数队列里面有callback函数在，它就会马上去执行callback函数。如果没有的话，它就会阻塞，不会占用CPU。</p>
</blockquote>
<p>发布方使用<code>spinOnce()</code>，等待订阅方接受信息并调用回调函数。</p>
<p>订阅方使用<code>spin()</code>，进入<code>spin</code>的死循环中，一直循环着接收发布方的消息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《ROS学习笔记》——第二节：话题通信的理论和实现]]></title>
        <id>https://horizain.github.io/post/kj-091kI2/</id>
        <link href="https://horizain.github.io/post/kj-091kI2/">
        </link>
        <updated>2021-08-21T15:04:20.000Z</updated>
        <summary type="html"><![CDATA[<p>话题通的模型中涉及三类角色：</p>
<ol>
<li>
<p>ROS Master</p>
</li>
<li>
<p>Talker</p>
</li>
<li>
<p>Listener</p>
</li>
</ol>
<p>ROS Master负责Talker和Listener的注册信息，并匹配话题(topic)相同的Talker和Listener建立连接，连接建立后，Talker发布的消息可以被Listener接收。建立连接后，可以不再需要ROS Master。</p>
]]></summary>
        <content type="html"><![CDATA[<p>话题通的模型中涉及三类角色：</p>
<ol>
<li>
<p>ROS Master</p>
</li>
<li>
<p>Talker</p>
</li>
<li>
<p>Listener</p>
</li>
</ol>
<p>ROS Master负责Talker和Listener的注册信息，并匹配话题(topic)相同的Talker和Listener建立连接，连接建立后，Talker发布的消息可以被Listener接收。建立连接后，可以不再需要ROS Master。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://horizain.github.io/post-images/1629558578305.jpg" alt="" loading="lazy"></figure>
<h3 id="1-理论流程">1、理论流程</h3>
<ol start="0">
<li>Talker注册</li>
</ol>
<p>Talker会通过RPC在ROS Master中注册信息，包括自身发布消息的话题名称、自己的RPC地址</p>
<ol>
<li>Listener注册</li>
</ol>
<p>同上，Listener会注册自身需要订阅的话题名和自己的RPC地址</p>
<ol start="2">
<li>ROS Master实现信息匹配</li>
</ol>
<p>ROS Master会根据注册表中的信息匹配Talker和Listener，并通过RPC先Listener发送Talker的RPC地址</p>
<ol start="3">
<li>Listener先Talker发送请求</li>
</ol>
<p>Listener 根据接收到的 RPC 地址，通过 RPC 向 Talker 发送连接请求，传输订阅的话题名称、消息类型以及通信协议(TCP/UDP)</p>
<ol start="4">
<li>Talker确认请求</li>
</ol>
<p>Talker接受到请求后，通过RPC先Listener确认连接信息，并发送自己的TCP地址</p>
<ol start="5">
<li>Listener与Talker建立连接</li>
</ol>
<p>Listener根据返回到的TCP地址与Talker建立网络连接</p>
<ol start="6">
<li>Talker向Listener发送消息</li>
</ol>
<p>连接建立后，Talker可以开始向Listener发布消息</p>
<h3 id="2-通俗理解">2、通俗理解</h3>
<ol start="0">
<li>
<p>女方（打电话）找媒婆</p>
</li>
<li>
<p>男方（打电话）找媒婆</p>
</li>
<li>
<p>媒婆匹配信息，把女方信息（打电话）给男方</p>
</li>
<li>
<p>男方给女方打电话</p>
</li>
<li>
<p>女方确认男方信息，并把自己的微信给男方</p>
</li>
<li>
<p>男方通过微信联系女方</p>
</li>
<li>
<p>男方和女方的后续沟通使用微信继续，而不再用媒婆传话</p>
</li>
</ol>
<p><strong>在通俗理解中，打电话即RCP通信协议，微信即TCP通信协议</strong></p>
<h3 id="3-注意事项">3、注意事项</h3>
<ol start="0">
<li>
<p>使用的通信协议有RPC和TCP，前期与ROS Master相关的通信是RCP协议，后面Talker与Listener的直接通信使用TCP协议</p>
</li>
<li>
<p>步骤0和步骤1的顺序先后无所谓</p>
</li>
<li>
<p>talker和listener可以同时存在多个</p>
</li>
</ol>
<h3 id="4-话题通信应用时的关注点">4、话题通信应用时的关注点</h3>
<ol start="0">
<li>大部分实现已被封装</li>
<li>话题的设置</li>
<li>发布者和订阅放的实现</li>
<li>信息载体</li>
</ol>
<h3 id="5-代码实现">5、代码实现</h3>
<p>上面介绍的流程中的大部分工作都有ROS系统抽象封装好了，我们只需要简单调用即可。</p>
<ol start="0">
<li>实例化ROS句柄：</li>
</ol>
<p><code>ros::NodeHandle nh;</code></p>
<ol>
<li>发布方的注册：</li>
</ol>
<p><code>ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;, 10);</code></p>
<ol start="2">
<li>订阅方的注册：</li>
</ol>
<p><code>ros::Subscriber sub = nh.subscribe&lt;std_msgs::String&gt;(&quot;chatter&quot;, 10, doMsg);</code></p>
<p>我们可以发现，双方的匹配是根据注册函数中的第一个参数（<code>chatter</code>）决定的，即话题名称。</p>
<p>双方注册自身的信息后，接下来的工作由ROS系统完成。</p>
<p><strong>发布方</strong>发布信息：</p>
<p><code>pub.publish(msg);</code></p>
<p><strong>订阅方</strong>注册好信息后，就一直处于待接收状态，我们需要将订阅方阻塞即可：<code>ros::spin();</code></p>
<p>循环读取接收的数据，并调用回调函数处理</p>
<h3 id="6-自定义msg">6、自定义msg</h3>
<p>std_msgs包括：</p>
<ul>
<li>int8, int16, int32, int64 (或者无符号类型: uint*)</li>
<li>float32, float64</li>
<li>string</li>
<li>time, duration</li>
<li>other msg files</li>
<li>variable-length array[] and fixed-length array[C]</li>
</ul>
<p>我们可以自定义复合类型的msg类型，比如创建一个自定义消息，该消息包含人的信息:姓名、身高、年龄。</p>
<p><strong>自定义msg流程：</strong></p>
<ol start="0">
<li>定义msg文件</li>
</ol>
<p>在package新建目录msg，添加Person.msg</p>
<p>内容为：</p>
<pre><code>string name
uint16 age
float64 height
</code></pre>
<ol>
<li>修改配置文件</li>
</ol>
<p><strong>package.xml</strong>中添加编译依赖与执行依赖</p>
<pre><code>&lt;build_depend&gt;message_generation&lt;/build_depend&gt;
&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;
</code></pre>
<p><strong>CMakeLists.txt</strong>编辑 msg 相关配置</p>
<pre><code>find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  std_msgs
  message_generation
)
# 需要加入 message_generation,必须有 std_msgs
</code></pre>
<pre><code>## 配置 msg 源文件
add_message_files(
  FILES
  Person.msg
)
</code></pre>
<pre><code># 生成消息时依赖于 std_msgs
generate_messages(
  DEPENDENCIES
  std_msgs
)
</code></pre>
<pre><code>#执行时依赖
catkin_package(
#  INCLUDE_DIRS include
#  LIBRARIES demo02_talker_listener
  CATKIN_DEPENDS roscpp rospy std_msgs message_runtime
#  DEPENDS system_lib
)
</code></pre>
<p>需要注意的是，上述语句的顺序不能搞错，否则会报错</p>
<ol start="3">
<li>编译</li>
</ol>
<p>执行命令<code>cmake_make</code></p>
<p>C++ 需要调用的中间文件(.../工作空间/devel/include/包名/xxx.h)</p>
<p>Python 需要调用的中间文件(.../工作空间/devel/lib/python3/dist-packages/包名/msg)</p>
<ol start="4">
<li>调用的注意事项</li>
</ol>
<p>为了方便代码提示以及避免误抛异常，需要先配置 vscode，将前面生成的 头文件和python文件路径配置进vscode的json配置文件</p>
<p>cpp：c_cpp_properties.json 的 includepath</p>
<p>python：settings.json的python.autoComplete.extraPaths</p>
<ol start="5">
<li>调用</li>
</ol>
<p><strong>发布者调用：</strong></p>
<p><code>ros::Publisher pub=nh.advertise&lt;current_msgs::Person&gt;(&quot;chatter_person&quot;, 1000);</code></p>
<p><strong>订阅者调用：</strong></p>
<p><code>ros::Subscriber sub = nh.subscribe&lt;current_msgs::Person&gt;(&quot;chatter_person&quot;, 10, doMsg);</code></p>
<p>可以发现，函数后面的尖括号包含了我们自定义的信息类型，这个是C++的语法知识，叫做模板，后面会详细补充相关知识。</p>
<p>其他与发布订阅标准信息类型一样。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一节补充笔记：编码过程中遇到的问题]]></title>
        <id>https://horizain.github.io/post/xDVXnfdtK/</id>
        <link href="https://horizain.github.io/post/xDVXnfdtK/">
        </link>
        <updated>2021-08-21T14:59:53.000Z</updated>
        <summary type="html"><![CDATA[<p>对第一节知识点的补充</p>
]]></summary>
        <content type="html"><![CDATA[<p>对第一节知识点的补充</p>
<!-- more -->
<h3 id="一-文件管理">一、文件管理</h3>
<p>我现在的项目文件管理目录如下：</p>
<figure data-type="image" tabindex="1"><img src="https://horizain.github.io/post-images/1629559247368.png" alt="" loading="lazy"></figure>
<p>在home目录下新建catkin_ws作为ROS系统的编译总目录，然后在下面新建demo0x_ws文件夹作为子项目的编译目录，我个人认为这样的安排是比较合理的，编码时只需要在对应的子项目下在终端中输入<code>code .</code>打开VSCode即可。</p>
<figure data-type="image" tabindex="2"><img src="https://horizain.github.io/post-images/1629559252964.png" alt="" loading="lazy"></figure>
<h3 id="二-vscode的插件使用">二、vscode的插件使用</h3>
<p>当前在vscode中安装的插件有：</p>
<figure data-type="image" tabindex="3"><img src="https://horizain.github.io/post-images/1629559258434.png" alt="" loading="lazy"></figure>
<p>亲测，安装完插件后，通过ROS插件新建Package，可以直接使用快捷键<code>Ctrl+Shift+B</code>调用编译</p>
<figure data-type="image" tabindex="4"><img src="https://horizain.github.io/post-images/1629559263746.png" alt="" loading="lazy"></figure>
<p>当然这个快捷编译是有前提的，介绍一下在catkin_ws总目录下新建一个子项目的流程：</p>
<p>1、在catkin_ws下新建一个子文件夹，<code>mkdir -p demo0x_ws/src</code></p>
<p>2、进入demo0x_ws目录下</p>
<p>3、在终端执行<code>catkin_make</code></p>
<p>4、在vscode中，右键src目录新建一个package，先输入package的名称，再输入需要的依赖软件包名，需要注意的是，package的名称要求是小写字母、下划线、数字的组合。</p>
<p>然后使用快捷键调用编译，你就会发现，出现了catkin_make的选项。</p>
<h3 id="三-在vscode中使用搜狗输入法的问题">三、在vscode中使用搜狗输入法的问题</h3>
<p>问题：在vscode中不能使用搜狗输入法，在系统其他环境中则正常</p>
<p>解决方法：从 Ubuntu Software Apps 安装的是 snap 软件包，也就是非 vscode 官方编译发布的安装包，有这个输入法bug，在VSCode 官网下载重新安装即可。</p>
<h3 id="四-原教程212中代码的修改">四、原教程2.1.2中代码的修改</h3>
<p>教程中的代码有一点小小的问题，发布的数字会比接收到的小1，经过下面的修改，即可解决。</p>
<figure data-type="image" tabindex="5"><img src="https://horizain.github.io/post-images/1629559272430.png" alt="" loading="lazy"></figure>
<p>把上面的代码修改为下面的，其实就是把显示数据的代码<code>rospy.loginfo</code>的顺序修改一下</p>
<figure data-type="image" tabindex="6"><img src="https://horizain.github.io/post-images/1629559277504.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《ROS学习笔记》——第一节：ROS的安装与调试]]></title>
        <id>https://horizain.github.io/post/9BG5hmaD4/</id>
        <link href="https://horizain.github.io/post/9BG5hmaD4/">
        </link>
        <updated>2021-08-21T14:54:10.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>我学习的文字文档和视频教程见下面两个链接，我个人认为这个教程写的还是很棒的。我写这个笔记作为我个人的学习与复习之用。</p>
</blockquote>
<p>文字教程：<a href="http://www.autolabor.com.cn/book/ROSTutorials/">Introduction · GitBook (autolabor.com.cn)</a></p>
<p>视频教程：<a href="https://www.bilibili.com/video/BV1Ci4y1L7ZZ?p=1">【奥特学园】ROS机器人入门课程《ROS理论与实践》零基础教程_哔哩哔哩_bilibili</a></p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>我学习的文字文档和视频教程见下面两个链接，我个人认为这个教程写的还是很棒的。我写这个笔记作为我个人的学习与复习之用。</p>
</blockquote>
<p>文字教程：<a href="http://www.autolabor.com.cn/book/ROSTutorials/">Introduction · GitBook (autolabor.com.cn)</a></p>
<p>视频教程：<a href="https://www.bilibili.com/video/BV1Ci4y1L7ZZ?p=1">【奥特学园】ROS机器人入门课程《ROS理论与实践》零基础教程_哔哩哔哩_bilibili</a></p>
<!-- more -->
<h3 id="一-安装ros的实操记录">一、安装ROS的实操记录</h3>
<p>ROS的系统版本是和Ubuntu系统版本高度统一的，这里我跟从教程，使用Ubuntu20.04，安装的ROS版本为noetic。</p>
<p><strong>1、首先设置安装源，亲测国内清华大学的源可以用</strong></p>
<p><code>sudo sh -c '. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/</code>lsb_release -cs<code>main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list'</code></p>
<p><strong>2、设置Key</strong></p>
<p><code>sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</code></p>
<p><strong>3、安装ros</strong></p>
<p>添加完ros安装源和key之后，首先需要更新一下apt</p>
<p><code>sudo apt update</code></p>
<p>然后键入</p>
<p><code>sudo apt install ros-noetic-desktop-full</code></p>
<h3 id="二-配置环境变量">二、配置环境变量</h3>
<p><code>echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</code></p>
<h3 id="三-卸载方法">三、卸载方法</h3>
<p><code>sudo apt remove ros-noetic-*</code></p>
<h3 id="四-测试ros">四、测试ROS</h3>
<p>打开三个命令行，然后按顺序分别键入：</p>
<p>1、<code>roscore</code></p>
<p>2、<code>rosrun turtlesim turtlesim_node</code></p>
<p>3、<code>rosrun turtlesim turtle_teleop_key</code></p>
<p><strong>注意: 在 ROS 版本 noetic 中无需构建软件包的依赖关系，没有<code>rosdep</code>的相关安装与配置。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python笔记本——获取文件大小]]></title>
        <id>https://horizain.github.io/post/G0Z6roMER/</id>
        <link href="https://horizain.github.io/post/G0Z6roMER/">
        </link>
        <updated>2021-05-11T05:31:32.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-python">
import os

print(os.path.getsize(filepath))
# 输出单位为字节
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python笔记本——openpyxl操作excel表格]]></title>
        <id>https://horizain.github.io/post/YOzVfWo7-/</id>
        <link href="https://horizain.github.io/post/YOzVfWo7-/">
        </link>
        <updated>2021-05-10T08:52:03.000Z</updated>
        <summary type="html"><![CDATA[<p>openpyxl是一个创建、修改excel文件的模块，保存的文件的扩展名一般为<code>.xlsx</code></p>
]]></summary>
        <content type="html"><![CDATA[<p>openpyxl是一个创建、修改excel文件的模块，保存的文件的扩展名一般为<code>.xlsx</code></p>
<!-- more -->
<h2 id="食用方法">食用方法</h2>
<h4 id="导入模块">导入模块</h4>
<pre><code class="language-python">
from openpyxl import Workbook, load_workbook

# Workbook：创建新文件

# load_workbook：读取已有文件

from openpyxl.style import Alignment, Font

# Alignment：设置单元格格式

# Font：设置字体格式
</code></pre>
<h4 id="打开文件">打开文件</h4>
<pre><code class="language-python">
if path.exists():
    wb = load_workbook(path)
else:
    wb = Workbook()

# 选择默认的表
# ws = wb.active

# 也可以创建删除已有的表，创建新表

</code></pre>
<h4 id="读写单元格">读写单元格</h4>
<p>写入单元格有两种方式：</p>
<pre><code class="language-python">
# 第一种
# 可以构建读写用字符串，形成类似'A1'这种形式的字符
temp = '%s%s' % (column, row)
ws[temp] = text

# 第二种
ws.cell(row=1, column=1, value=text)
</code></pre>
<p>读取单元格同样有两种方法：</p>
<pre><code class="language-python">
# 第一种
ws['A1'].value

# 第二种
ws.cell(row=1, column=1).value
</code></pre>
<h4 id="合并单元格并居中">合并单元格并居中</h4>
<pre><code class="language-python">
# 构造例如 `A1:B2` 这种形式的字符
ws.merge_cells('%s%s:%s%s' % (start_column, start_row, end_column, end_row))

# 单元格合并后标号等于合并前左上角第一个单元格的标号
ws[&quot;%s%s&quot; % (start_column, start_row)].alignment = Alignment(vertical='center', wrapText=True)
# vertical='center'：单元格垂直居中
# wrapText=Tru：自动换行
</code></pre>
<blockquote>
<p>注：合并单元格的内容为合并前左上角单元格的内容，所以合并并写入的操作顺序为“先写入左上角，再合并”</p>
</blockquote>
<h4 id="保存文件">保存文件</h4>
<pre><code class="language-python">
ws.save(abspath)
# abspath是以.xlsx扩展名结尾的绝对地址，（相对地址也可以），推荐使用pathlib构造
# 我是这样用的
docname = 'name.xlsx'
wb.save(Path.joinpath(rootPath, docname))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python笔记本——shutil文件操作]]></title>
        <id>https://horizain.github.io/post/bbkKceax1/</id>
        <link href="https://horizain.github.io/post/bbkKceax1/">
        </link>
        <updated>2021-05-07T09:11:03.000Z</updated>
        <summary type="html"><![CDATA[<p>我主要是使用这个模块复制文件和文件夹</p>
]]></summary>
        <content type="html"><![CDATA[<p>我主要是使用这个模块复制文件和文件夹</p>
<!-- more -->
<h2 id="用法"><strong>用法</strong></h2>
<pre><code># 判断文件/文件夹并复制
for binPath in seconddir.iterdir():
    if binPath.is_file():
        srcPath = binPath.resolve()
        # 复制文件
        shutil.copy(srcPath, inputPath)
    else:
        # 复制文件夹
        shutil.copytree(binPath.resolve(), Path.joinpath(inputPath,binPath.name), dirs_exist_ok=True)

# dirs_exist_os=True：忽略已有文件夹
# Path.joinpath(inputPath,binPath.name)：合成文件夹的目的地址
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python笔记本——pathlib使用简述]]></title>
        <id>https://horizain.github.io/post/DWvXQWaZE/</id>
        <link href="https://horizain.github.io/post/DWvXQWaZE/">
        </link>
        <updated>2021-05-07T09:09:00.000Z</updated>
        <summary type="html"><![CDATA[<p>pathlib 是一个面向对象的文件系统路径模块。下面是我是用较多的函数和使用方法：</p>
]]></summary>
        <content type="html"><![CDATA[<p>pathlib 是一个面向对象的文件系统路径模块。下面是我是用较多的函数和使用方法：</p>
<!-- more -->
<h3 id="快速食用方法">快速食用方法</h3>
<p>导入模块</p>
<p><code>from pathlib import Path</code></p>
<p>新建一个Path对象</p>
<p><code>dstbinPath = Path(inputPath)</code></p>
<p>获取文件所在的<strong>相对路径</strong>的<strong>上级路径</strong></p>
<p><code>rootPath = Path.cwd().parent</code></p>
<p>parent属性可以<strong>链式调用</strong>，比如</p>
<p><code>Path.cwd().parent.parent.parent.parent</code></p>
<p>Path对象的parents属性可以拿到各级目录列表(索引值越大越接近root)</p>
<p>拼接路径</p>
<p><code>logPath = Path.joinpath(rootPath, 'errorlog')</code></p>
<p><strong>遍历</strong>文件夹文件</p>
<pre><code class="language-python">for sub in logPath.iterdir():
    if sub.is_file():
        # 获取文件的绝对路径
        srcPath = sub.resolve()
</code></pre>
<p>判断文件后缀扩展名</p>
<p><code>if logfile.suffix == '.json':</code></p>
<p>删除文件</p>
<p><code>file.unlink()</code></p>
<h2 id="对应的-os-模块的工具">对应的 <a href="https://docs.python.org/zh-cn/3/library/os.html#module-os"><code>os</code></a> 模块的工具</h2>
<table>
<thead>
<tr>
<th style="text-align:left">os 和 os.path</th>
<th style="text-align:left">pathlib</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.path.html#os.path.abspath"><code>os.path.abspath()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.resolve"><code>Path.resolve()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.html#os.chmod"><code>os.chmod()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.chmod"><code>Path.chmod()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.html#os.mkdir"><code>os.mkdir()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.mkdir"><code>Path.mkdir()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.html#os.makedirs"><code>os.makedirs()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.mkdir"><code>Path.mkdir()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.html#os.rename"><code>os.rename()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.rename"><code>Path.rename()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.html#os.replace"><code>os.replace()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.replace"><code>Path.replace()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.html#os.rmdir"><code>os.rmdir()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.rmdir"><code>Path.rmdir()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.html#os.remove"><code>os.remove()</code></a>, <a href="https://docs.python.org/zh-cn/3/library/os.html#os.unlink"><code>os.unlink()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.unlink"><code>Path.unlink()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.html#os.getcwd"><code>os.getcwd()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.cwd"><code>Path.cwd()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.path.html#os.path.exists"><code>os.path.exists()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.exists"><code>Path.exists()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.path.html#os.path.expanduser"><code>os.path.expanduser()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.expanduser"><code>Path.expanduser()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.home"><code>Path.home()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.html#os.listdir"><code>os.listdir()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.iterdir"><code>Path.iterdir()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.path.html#os.path.isdir"><code>os.path.isdir()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.is_dir"><code>Path.is_dir()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.path.html#os.path.isfile"><code>os.path.isfile()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.is_file"><code>Path.is_file()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.path.html#os.path.islink"><code>os.path.islink()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.is_symlink"><code>Path.is_symlink()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.html#os.link"><code>os.link()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.link_to"><code>Path.link_to()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.html#os.symlink"><code>os.symlink()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.symlink_to"><code>Path.symlink_to()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.html#os.readlink"><code>os.readlink()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.readlink"><code>Path.readlink()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.html#os.stat"><code>os.stat()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.stat"><code>Path.stat()</code></a>, <a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.owner"><code>Path.owner()</code></a>, <a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.group"><code>Path.group()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.path.html#os.path.isabs"><code>os.path.isabs()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.PurePath.is_absolute"><code>PurePath.is_absolute()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.path.html#os.path.join"><code>os.path.join()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.PurePath.joinpath"><code>PurePath.joinpath()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.path.html#os.path.basename"><code>os.path.basename()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.PurePath.name"><code>PurePath.name</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.path.html#os.path.dirname"><code>os.path.dirname()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.PurePath.parent"><code>PurePath.parent</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.path.html#os.path.samefile"><code>os.path.samefile()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.Path.samefile"><code>Path.samefile()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/os.path.html#os.path.splitext"><code>os.path.splitext()</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/pathlib.html#pathlib.PurePath.suffix"><code>PurePath.suffix</code></a></td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
</feed>